
### Java程序执行过程

Java源码经过编译器编译为.class文件（字节码文件）由JVM解释执行

**字节码文件：** 实现Java语言跨平台。字节码文件包含类的字段、方法、实现接口等信息

## JVM加载字节码文件

### JVM分区

1. 方法区 存放要加载的类的信息类名、访问修饰符、常量池、字段描述、方法描述等，类中的静态变量，类中定义为final类型的常量，类中的Field信息，类中的方法信息，即时编译后的代码等数据。

    HopSpot虚拟机设计团队把GC分代收集扩展至方法区，使用永久代来实现方法区，这样HopSpot的垃圾收集器可以像管理Java堆区的方式来管理方法区，省去为方法区编写内存管理代码的工作，但是容易出现内存溢出，**方法区可以选择不实现垃圾收集** 在方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。

    **运行时常量池：** 是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号的引用，这部分将在类加载后进入方法区的运行时常量池中存放
    


2. 虚拟机栈 ：执行引擎运行字节码时的运行时内存区，采用栈帧的形式保存每个方法的调用运行数据，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作数栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。
    
    **局部变量表：存放编译期可知的基本数据类型，对象引用（不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型**

    **当进入一个方法时，这个方法在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量的大小**

    **栈溢出：线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError异常**

3. 本地方法栈 执行引擎调用本地方法时的运行时内存区，在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定

4. 堆 运行时数据区，对象的存储区，在虚拟机启动时创建，所有对象实例和数组都要在堆上分配

    **堆区是GC的主要区域，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续，如果堆中没有内u才能完成实例分配，并且堆也我无法扩展，就会抛出OOM异常**

5. 程序计数器 ：线程所执行的字节码的行号指示器。通过改变计数器的值来选取下一条要执行的字节码指令。保存正在执行的程序的内存地址，Java多线程执行，多线程交叉执行时，被中断的线程的程序当前运行到的内存地址需要保存，在线程恢复后继续执行，每个线程对应一个独立的程序计数器，各个线程之间的计数器互不影响

## 对象创建

Java程序中创建对象使用new关键字，在虚拟机中创建对象的过程：

虚拟机遇到new指令，检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就会执行引用的类的加载过程。在类加载检查通过后虚拟机将为 **新生对象分配内存** 对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间相当于在JAVA堆区上为对象划分一块确定大小的区域。

***指针碰撞：*** Java堆区是规整的。所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，在分配内存的时候把指针向空闲的区域挪动一段与对象大小相等的距离

***空闲列表：*** Java堆区不规整，已使用的内存和空闲的内存相互交错，虚拟机在分配空间的时候必须维护一个列表，用来记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

选择哪种分配方式由Java堆是否规整决定，而 **Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定** 。

在并发情况下给对象分配内存空间的时候会出现线程不安全的情况，在给A对象分配空间，指针还没来得及修改对象B由同时使用了原来的指针来分配内存的情况。

**解决方案：**

1. 对分配内存空间的动作进行同步处理--虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
2. 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲

在对象分配好空间后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

Java程序在执行完new指令后接着会执行<init>方法，把对象按照程序员的意愿进行初始化

## 对象的内存布局

HopSpot虚拟机中对象在内存中存储的布局：对象头、实例数据、对象填充

对象头包括俩部分信息，第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄、锁状态表只、线程持有的锁、偏向线程ID、偏向时间戳

**对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，如果对象是一个Java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的原始数据中却无法确定数组的大小**

实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

### 对象的访问定位

建立对象是为了使用对象，我们的Java程序需要通过栈上的引用数据来操作堆上的具体对象。由于引用类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位访问堆中对象的具体位置，所以对象访问方式也式取决于虚拟机实现而定的

***使用句柄访问：*** Java堆中会划分一块内存来作为句柄池，引用中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息

***使用直接指针访问：*** JAVA堆对象的布局中存在访问类型数据的相关信息，而引用中存储的直接就是对象地址

**使用句柄来访问的最大好处就是变量表的引用中存储的是稳定的句柄地址，在对象被移动时只改变句柄中的实例数据指针，而引用本身不需要修改**

**使用直接指针访问方式的最大好处就是速度更快，节省了一次指针定位的时间开销 HopSpot使用第二种方式进行对象访问的**

## 类加载（加载字节码）：

加载->验证->准备->解析->初始化

### 运行字节码

执行引擎找到main()方法，执行其中的字节码指令

## GC

在对堆区进行垃圾收集的时候，需要判断这些对象中哪些还存活，哪些已经死去

判断对象的存活状态：

1. 引用计数算法

给对象一个引用计数器，每当有一个地方引用的时候计数器+1；引用失效的时候，计数器-1；任何时刻计数器为0的对象就是不可能再被使用的。

使用引用计数器解决不了对象之间循环引用的问题

2. 可达性分析算法

通过一系列的称为"GC Roots"的对象作为起始点从这些结点开始向下搜索，搜索走过的路程称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象时不可用的。

Java中可以作为GC Roots的对象包括：

1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么将会被第一次标记并且进行一次筛选，筛选的条件是对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这俩种情况都视为没有必要执行
如果对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-Queue队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。虚拟机会触发这个方法，并不会等待finalize方法结束，因为如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统奔溃。如果对象在finalize()方法执行期间与引用链上的任意一个对象建立关联，那么将会在第二次标记时将被移除出即将回收集合；如果对象没有建立关联，那么将会被回收。

任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再执行

### 永久代的垃圾回收(JDK1.8后没有永久代)

永久代的垃圾收集主要回收俩部分的内容：废弃常量和无用的类。

废弃的常量比较容易判断，但对无用的类的要求比较苛刻，即使满足也只是可以回收，不是一定会被回收掉

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
2. 加载该类的ClassLoader已经被回收；
3. 该类对应的java.lang.Class对象没有在任何地方被引用

### 垃圾收集算法

1. 标记-清除算法
    - 标记出所有要回收的对象，在标记完成后统一回收所有被标记的对象
    - 缺点：标记清除的效率都不高；标记清除会产生大量不连续的内存碎片，空间碎片太多导致在程序运行过程中需要分配较大对象时，提前触发一次GC
2. 复制算法
    - 将可用内存按容量分为大小相等的俩块，每次只使用其中的一块。当一块内存用完，就将还存活的对象复制到另外一块上面去，然后再把已使用过的内存空间一次清理掉。这样每次都是对整个半区进行内存回收，内存分配时也就不考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可
    - 缺点：占内存缩小为原来的一般，代价高
3. 标记整理算法
    - 在对象存活率高时进行较多的赋值操作会降低效率。更关键的时内存空间的浪费，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法
    -标记整理算法让所有存活的对象向一段移动，然后直接清理掉边界以外的内存
4. 分代收集算法
    - 当前商业虚拟机的垃圾收集的首选算法，把堆分为新生代和老生代，分局各个年代的特点采用合适的收集算法
    - 新生代中，每次垃圾收集时都会有大批对象死去，只有少量存活，就采用复制算法，只需要付出少量存活对象的赋值成本就可以完成收集。老年代中就需要采用标记清除算法或者标记整理算法

堆内存分成了3块：

1. 年轻代：新对象和没达到一定年龄的对象年
2. 老年代：对象被长时间使用的对象。老年代的内存空间应该比年轻代的内存空间更大
3. 元空间：像一些方法中的操作的临时变量，对象等

**最初的永久代是需要在JVM堆内存里面划分，元空间是物理内存使用**

年轻代采用复制算法进行垃圾收集，年轻代的内存划分为一块较大的Eden空间和俩块较小的Surivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Sruvivor中还存活的对象一次性的复制到另一块Survivor空间上最后清理掉刚才使用的Eden和刚才使用的Survivor空间


<img src="/images/Blog/jvm.png" >

## 类加载

类加载的生命周期：

1. 加载
    - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
2. 验证
    - 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
    - Class文件可以直接编写，如果编写的Class文件不进行验证，不安全
    - 文件格式验证  元数据验证  字节码验证 符号引用验证
3. 准备
    - 为类变量分配内存---在方法区中进行分配
    - 设置类变量初始化的阶段
    - 准备阶段进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量，实例变量在对象实例化的时候随对象一起分配在Java堆中
    - 准备阶段的初始值通常情况下是零值 如果是常量就会为当前设置的值
4. 解析
    - 虚拟机将符号引用替换为直接引用的过程
    - 类或接口的解析+字段解析+类方法解析+接口方法解析
5. 初始化
    - 执行类中定义的Java程序代码
6. 使用
7. 卸载 

**类加载的顺序：加载 验证 准备 初始化 卸载都是确定的解析可以在初始化阶段之后再开始**

虚拟机没有强制约束加载，但是对于初始化阶段，虚拟机规范则是严格规定了有且只有五种情况必须立即对类进行初始化("加载，验证，准备自然在初始化之前)

1. 使用new关键字实例化对象时，读取或设置一个类的静态字段的时候，以及调用一个类的静态方法的时候
2. 使用反射机制进行调用但父类没有进行过初始化，则需先触发其初始化
3. 当虚拟机启动的时候，用户需要制定一个要执行的主类，虚拟机会先初始化这个主类
4. 当初始化一个类的时候，其父类没有进行过初始化，则需先出发其父类的初始化

## 类与类加载器

类加载器虽然只用于实现类的加载动作，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的类命名空间。

比较俩个类是否相等：这俩个类由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机夹杂爱，只要加载他们的类加载器不同，那么这俩个类就必定不相同。

### 双亲委派模型：

启动类加载器(Bootstrap ClassLoader)：由C++语言实现，是虚拟机自身的一部分；启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接用null代替即可


扩展类加载器(Extension ClassLoader)

应用类（系统类）加载器(Application ClassLoader):加载用户类路径上所指定的类库

其他类加载器：由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader

**双亲委派模型的工作过程：** 如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一个层次的类加载器都是如此，因此所有的类加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求的时候，子加载器才会尝试自己区加载
