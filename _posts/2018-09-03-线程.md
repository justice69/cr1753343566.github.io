---
layout: post                  
title: "线程"             
date: 2018-08-03               
tag:  Java基础
---
### java多线程

Java中的多线程是一种抢占式的机制而不是分时机制，抢占式的机制是有多个线程处于可运行状态，但只有一个线程运行

1. 什么是线程
    
    多任务：同一时刻运行多个程序的能力，每一个任务称为一个线程。可以同时运行一个以上线程的程序称为多线程程序

    ***Java编写的程序都运行在JVM中，在JVM的内部，程序的多任务是通过线程来实现的，每用java命令启动一个java应用程序，就会启动一个JVM进程，在同一个JVM进程中，有且只有一个进程，就是它自己，在这个JVM环境中，所有程序代码都是以线程来运行***

    一般常见的Java应用程序都是单线程的，比如helloworld程序在运行时启动一个JVM进程，JVM找到程序的入口点mian()，运行main()方法，这样就产生一个线程，这个线程称为主线程。当main()方法结束后，主线程运行完成。JVM进程也退出

    对于一个程序的多个进程来说，多线程共享进程的内存块，当有新的线程产生的时候，操作系统不分配新的内存，而是让新的线程共享原有的进程块的内存。因此，线程间的通信很容易，速度也很快。不同的进程因为处于不同的内存块，因此进程之间的通信相对困难

    ***进程是指一个内存中的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程***

    线程是指进程中的一个执行流程，一个进程可以运行多个线程，进程中的多个线程共享进程的内存

    Java中线程是指java.lang.Thread类的一个实例或线程的执行，使用java.lang.Thread或java.lang.Runnable接口编写代码定义、实例化、启动新线程

    Java中每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行。main()方法运行在一个线程内，称为主线程。一旦创建一个新的线程，就产生一个新的调用栈

    ***线程分为两类：用户线程和守候线程。当所有用户线程执行完毕后，JVM自动关闭。但是守候线程却不独立与JVM，守候线程一般由操作系统或用户自己创建的。***


2. 定义线程

    1.扩展java.lang.Thread类以及实现Runnable接口，此类中有run方法，public void run(),如果线程是独立的Runnable运行对象构造的，则调用该Runnable对象的run()方法；否则该方法不执行任何操作，Thread的子类也应该重写该方法

3. 实例化线程

    - 如果是扩展了java.lang.Thread类的线程，则直接调用new即可
    - 如果是实现了java.lang.Runnable接口的类，则调用Thread的构造方法

4. 启动线程

    在线程的Thread对象上调用start()方法，而不是run()或别的方法
    在调用start()方法之前，线程处于新状态中，新状态有一个Thread对象，但没有一个真正的线程
    在调用start()方法之后，JVM中发生：
    启动新的执行线程（具有新的调用栈）
    该线程从新状态转移到可运行状态
    当该线程获得运行机会时，其目标run()方法将运行
    
    ***线程对象调用start()和调用run()方法的区别:前者调用实例方法，只有主线程执行，后者是启动线程

5. 线程的状态：创建、就绪、运行、阻塞、终止状态

    创建状态：在程序中用构造方法创建了一个新的线程对象后，新的线程对象就处于创建状态，此时，它已经获取到了相应的资源，但还没有处于可运行状态，这时通过Thread类的方法来设置线程对象的属性，如设置线程名（setName()）、设置线程优先级（setPriority()）等

    就绪状态：线程创建之后，就可以通过调用start()方法启动线程，即进入就绪状态。此时，线程将进入线程队列排队，等待CPU资源，这表明它已经具备了运行条件，在未获得CPU资源时，仍不能真正执行

    运行状态：当就绪状态的线程获得CPU资源时，即可转入运行状态，执行run()方法。对于只有一个CPU的机器而言，任何时刻只能有一个处于运行状态的线程占用CPU，即获得CPU资源

    阻塞状态：一个正在运行的线程因某种原因不能继续运行时，进入阻塞状态。阻塞状态是一种“不可运行”的状态，而处于这种状态的线程在得到一个特定的事件之后会转回可运行状态

    死亡状态：一个线程的run()方法运行完毕，线程则进入死亡状态。处于死亡状态的线程不具有继续运行的能力

6. 使线程暂停执行的条件：

    - 线程优先级比较低，因此它不能获得CPU资源。
    - 使用sleep()方法使线程休眠。
    - 通过调用wait()方法，使线程等待。
    - 通过调用yield()方法，线程显式出让CPU控制权。
    - 线程由于等待一个文件I/O事件被阻塞。

7. 线程调度

    <img src="/images/Blog/xc.png" >

    优先级高的线程获得cpu资源的概率大（优先级高的不一定先执行），默认优先级为5，优先级范围为1-10

    线程休眠：让线程暂时休眠，线程进入阻塞状态，休眠结束后线程进入可运行状态

8. **线程安全**

    Java的内存模型中有主内存和线程的工作内存之分，主内存上存放的是线程共享的变量(实例字段，静态字段和构成数组的元素)，线程的工作内存是线程私有空间存放线程Sioux的变量。线程在工作的时候如果要操作主内存上的共享变量，为了获得更好的执行性能并不是直接去修改主内存而是会在线程私有的工作内存中创建一份变量的拷贝，在工作内存上对变量的拷贝修改后再把修改的值刷回主内存的变量中去，JVM提供了8种原子操作来完成这一过程：lock,unlock,read,load,use,assign,store,write。
    
    如果只有一个线程并不会出什么问题，但当有多个线程同时操作主内存的变量，因为8种操作的非连续性和线程抢占cpu执行的机制就会带来冲突的问题，也就是多线程的安全问题。线程安全的定义就是：**如果线程执行过程中不会产生共享资源的冲突就是线程安全的**

## Java保证线程安全的几种机制：
- 互斥同步锁(悲观锁) 

    1)Synchorized

    2)ReentrantLock

    互斥同步锁也叫阻塞同步锁，特征是会对没有获取锁的线程进行阻塞

    互斥同步锁就是以互斥的手段达到顺序访问的目的，操作系统提供了很多互斥机制比如信号量，互斥量，临界区资源等来控制在某一个时刻只能有一个或者一组线程访问同一个资源

    互斥同步锁都是可重入锁，好处是可以保证不会死锁，但比较消耗性能
    
- 非阻塞同步锁(乐观锁)
    
    非阻塞同步锁也叫乐观锁，相比悲观锁，它会先进行资源在工作内存中的更新，然后根据与主存中旧值的对比来确定在此期间是否有其他线程对共享资源进行了更新，如果旧值与期望值相同，就认为没有更新，可以把新值写回内存，否则就一直重试直到成功。它的实现依赖于处理器的机器指令：CAS

    非阻塞锁不可重入，否则会造成死锁
    
- 无同步方案

    1)可重入代码
    在执行的任何时候都可以中断-冲入执行而不会产生冲突，特点就是不会依赖堆上的共享资源

    2)ThreadLocal/Volaitile
    线程本地的变量，每个线程获取一份共享变量的拷贝，单独进行处理

    3)线程本地存储    
    如果一个共享资源一定要被多线程共享，可以尽量让一个线程完成所有的处理操作，比如生产者消费者模式中，一般会让一个消费者完成对队列上资源的消费。典型的应用是基于请求-应答模式的web服务器的设计


