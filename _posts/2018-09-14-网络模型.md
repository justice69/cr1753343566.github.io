---
layout: post                  
title: "网络模型"             
date: 2018-09-14               
tag:  计算机网络
---

## 网络分层

### OSI参考模式

1. 物理层：利用传输介质为数据链路层提供物理连接，比特流传输

2. 数据链路层：为网络层提供服务，解决两个相邻结点之间的通信问题，负责透明传输 **数据帧** ，传送的协议数据单元称为数据帧，数据帧中包含物理地址（MAC）、控制码、数据及校验码等信息，该层的主要作用是通过 **校验、确认和反馈重发手段，将不可靠的数据链路层转换为对网络层来说无差错的数据链路**，此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞
    
    数据链路层分为俩个子层：**逻辑控制链路层和介质访问控制子层**
    每个网卡都有一个唯一的MAC地址

3. 网络层： 为传输层提供服务，负责主机通信，传送的协议数据单元称为数据包或分组。解决如何使数据包通过各结点传送的问题，即通过 **路由选择算法**将数据包送到到目的地。此外，为避免通信子网中出现过多的数据包而造成网络堵塞，需要对流入的数据包数量进行控制（**拥塞控制**）。当数据包要跨越多个通信子网才能达到目的地时，还要解决网际互连问题

    网络层的三个最基本功能：地址、路由、分组和重组。
    网络层上最重要的协议IP
    IPV6与TPV4的区别：使用了不同位数的二进制整数作为地址：IPV4使用32位二进制地址，IPV6使用128位二进制地址。
    
    IPV4地址表示方法位用点隔开的4各数字，每个数字的取值为0~255，即每一个字节的大小，如192.168.1.1

    IPV6地址表示为用：隔开的8各字，每个字都用16进制来表示

4. 传输层： 传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，负责进程间通信，包括差错处理控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节

    传输层上最重要的俩个协议是TCP和UDP。TCP是面向连接的协议，UDP是无连接的协议
    
    TCP(传输控制协议)：TCP在传输数据之前必须建立一个连接 TCP做了很多工作来确保传输的可靠性，包括 **建立、管理和终止连接，确认和重传。同时TCP还提供分段和重组，流量控制等
    
    UDP(用户数据报协议)：UDP是一种简单的传输层协议，所以它并不能提供可靠的数据传输。UDP只是把应用程序发给它的数据打包成一个UDP数据报，然后再把这个数据报传给IP。
    
    TCP会把应用程序发来的数据根据需要分成若干个大小合适的TCP段，而UDP只是把所有数据打包成一个UDP数据报

    有很多的应用程序同时使用TCP和UDP，他们都会把数据交给TCP/UDP，而TCP/UDP也会接受来自IP的、包含指向不同应用程序的数据，所以就需要一种方法来区别应用程序，这种方法就是通过端口号来进行 ***多路复用*** 或 ***多路分解***。端口号是一个16为的二进制数

    **多路复用**：多路复用只是应用程序把数据交给TCP和UDP的时，TCP会把这些数据分成若干个TCP段，UDP则会产生一个UDP数据报，在这些TCP段和UDP数据报中，会填入应用程序指定的源端口号和目标端口号，源端口号用于标识发送的应用程序，目标端口号用于指明在目标机器上应该接收数据的目标应用程序。

    **多路分解**：多路复用的逆过程，挡在==当在目标机器上的TCP或者UDP接收到TCP段和UDP数据报时，会检查它们的目标端口号，然后根据不同的目标端口号把爱数据分发给不同的应用程序。

5. 会话层：两个应用程序进程之间的逻辑连接，两个应用程序通过逻辑连接在一段时间内交换数据，会话层的作用就是为创建、管理和终止会话提供必要的方法

    会话层负责管理和确定传输模式，计算机可以由三种模式来传输数据： **单向、半双工、全双工**。

    - 单向：数据只可以单向传输
    - 半双工：允许数据单向传输，但是一个时刻只能有一个方向传输，不能同时双向传输
    - 全双工： 数据可以双向传输

6. 表示层：数据的表示，数据的 **转换、压缩、加密**。工作在表示层的加密协议--SSL。

7. 应用层：当用户使用浏览器来打开网页时，需要利用DNS提供的域名解析服务，来获取网址对应的IP地址，然后再通过另外一个协议HTTP来下载页面内容。在这个过程中出现的两个协议（DNS和HTTP）都是工作在应用层上的协议。

    应用层的其他协议：

    - FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件。
    - DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址
    - POP3：邮件接收协议，用于从POP3服务器接收邮件。
    - SMTP：邮件发送协议，用户通过SMTP服务器发送邮件。

### TCP/IP四层模型

1. 应用层：OSI参考模型的应用层，表示层，会话层的综合
2. 传输层：对应OSI参考模式的传输层
3. 网络层：对应OSI参考模式的网络层
4. 数据链路层：对应OSI参考模式的网络层

### TCP/IP参考模式每层使用的协议有：

1. 应用层：TFTP,HTTP,SNMP,FTP,SMTP,POPS,DNS
2. 传输层：TCP,UDP
3. 网络层：IP,ICMP,OSPF,EIGRP,IGMP
4. 数据链路层：SLIP,CSLIP,PPP,MTU

每一个抽象层都建立在低一层提供的服务上，并为上层服务。

Socket处于应用程序的传输层和应用层之间，设计了一个socket抽象层，传输层的低一层的服务提供给socket抽象层，socket抽象层再提供给应用层，这三层之间以TCP/IP为基础进行通信

## TCP/IP协议

***TCP/IP协议***：网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。

### TCP三次握手：

1. 第一次握手：客户端尝试连接服务器，向服务器发送syn包，syn=j，客户端进入***SYN_SEND***状态等待服务器确认
2. 第二次握手：服务器接收客户端syn包并确认(ack=j+1),同时向客户端发送一个SYN包(syn=k) ,即SYN+ACK包，此时服务器进入 ***SYN_RECV状态***
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ***ESTABLISHED状态***，完成三次握手

<img src="/images/Blog/scws.gif" >

#### TCP三次握手的原因：

假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是俩次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的时候数据丢失，客户端认为连接没有建立，会进行重传SYN包。假设每次发送的数据都在丢失，那么客户端就会一直重传SYN，服务器端产生多个无效链接，占用资源，这个服务器可能会奔溃，SYN洪水冲击，第三次握手是为了防止：如果客户端没有收到服务器返回确认的报文，客户端会放弃连接，重新启动一条连接请求，但问题在于：服务器不知道客户端有没有收到，会收到俩个连接，浪费连接开销

### TCP四次挥手：

1. 第一次挥手：客户端给服务器发送FIN包，用来关闭客户端到服务器的数据传送
2. 第二次挥手：服务器接收到FIN后，发回有一个确认信号ACK
3. 第三次挥手：服务器发送FIN包，请求关闭服务器到客户端的数据传送
4. 第四次挥手：客户端收到服务器发送的FIN后，发回ACK确认

<img src="/images/Blog/schs.png" >

客户端发送FIN后，进入 ***终止等待状态***，服务器收到客户端连接释放报文段后，就立即给客户端发送确认，服务器就进入 ***CLOSE_WAIT*** 状态，此时TCP服务器进程同指高层应用进程，因而从客户端到服务器的连接就释放了。此时是“半关闭状态”，客户端不可以发送给服务器数据，而服务器可以发送给客户端。此时，如果服务器没有数据报发送给客户端，其应用程序就通知TCP释放连接，然后发送给客户端 ***连接释放数据报***，并等待确认。客户端发送确认后，进入 **TIME_WAIT** 状态，但是此时TCP连接还没有释放，然后经过等待计时器设置的2MSL后，才进入到CLOSE状态。

#### 为什么要2MSL时间？

MSL就是最大报文生存时间，是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃，TCP的TIME_WAIT需要等待2MSL，当TCP的一段发起主动关闭，三次回收完成后发送第四次挥手的ACK包后就进入这个状态，等待2MSL为了防止最后一个ACK包没有收到，那么对方在超时后将重发第三次挥手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。

#### 为什么四次挥手？

双方关闭连接要经过双方都同意。所以，首先是客服端给服务器发送FIN，要求关闭连接，服务器收到后会发送一个ACK进行确认。服务器然后再发送一个FIN，客户端发送ACK确认，并进入TIME_WAIT状态。等待2MSL后自动关闭。





