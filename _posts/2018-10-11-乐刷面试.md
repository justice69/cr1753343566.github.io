---
layout: post                  
title: "乐刷面试"             
date: 2018-09-28               
tag:  Interview
---

## 1. 序列化

- 什么是序列化：把对象转换为字节序列的过程称为对象的序列化。

    代码运行时，很多对象，可以是一个，也可以是一类对象的集合，很多的对象数据，我们想要持久保存起来，就需要序列化，就是把内存里面的这些对象变成一连串的字节描述的过程，就是保存为文件

- 什么是反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

### 什么情况下需要序列化

1. 内存中的对象状态保存到一个文件中或者数据库中时候；
2. 当你想用套接字在网络上传送对象的时候；
3. 当你想通过RMI传输对象的时候；

### **序列化的时候会给对象一个id，这个id有什么作用**

决定序列化后能否成功反序列化，简单来说，java的序列化机制是通过在运行时判断 **类的serialVersionUID来验证版本一致性的** ，在进行反序列化的时候，JVM会把传来的字节流中的 **serialVersionUID与本地实体类中的serialVersionUID进行比较** ，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常

如果不显示的定义，Java序列化机制会根据编译时的class **自动生成一个serialVersionUID作为序列化版本比较** ，这种情况下，只有 **同一次编译生成的class才会生成相同的serialVersionUID。** 

当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，  **这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败**

## 2. 写一个sql语句，怎么判断它的性能

使用Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看 SQL 语句的执行效果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。

使用Explain执行sql语句的结果会展现一些属性

1. id：这是SELECT的查询序列号
2. select_type：select_type就是select的类型
3. table：显示这一行的数据是关于哪张表的
4. type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
5. possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6. key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7. key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8. ref：显示使用哪个列或常数与key一起从表中选择行。
9. rows：显示MySQL认为它执行查询时必须检查的行数。
10. Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。

怎么判断语句的正确性：

定义要检验的语句：DECLARE @sql NVARCHAR(MAX)
正确的语句：SET @sql = 'select * from Report_Test1'

## 3. jvm相关

参考博文(https://cr1753343566.github.io/2018/09/JavaGc%E6%9C%BA%E5%88%B6/)

## 4. 索引

什么是索引：提高数据库查询速度的数据结构，同时数据库需要消耗更多的资源去维护和存储该数据结构。索引可以快速的定位数据，而不需要每次查询数据库表中的所有数据

- 聚簇索引
    > 聚簇索引的顺序与数据库中数据的存储顺序相同，因此一个表最多建立一个聚簇索引正因索引顺序与物理存储顺序相同，因此需要检索的下条记录与当前记录相邻，可以有效减少数据块的读取次数
- 非聚簇索引
    > 非聚簇索引的顺序与数据的存储顺序无关，非聚簇索引中存放数据物理存储地址的指针。一个表可以建立多个非聚簇索引，

### Hash索引：

索引检索效率高于B树结构的索引，索引的检索可以一次到位，查询效率高于B树索引

1. Hash索引不能用作范围查询
2. Hash索引无法被用来避免数据的排序操作
3. Hash索引不能利用部分索引键查询
4. Hash索引在任何时候都不能避免表扫描
    
B树索引的物理文件大多是采用二叉平衡树的结构来存储的

InnoDB引擎的索引是以B+树的结构

### 索引是不是越多越好：

大多数情况下索引能大幅度提高查询效率，但：
数据的变更（增删改）都需要维护索引，因此更多的索引意味着更多的维护成本更多的索引意味着也需要更多的空间 

### 什么样的字段不适合建索引？

一般来说，列的值唯一性太小（如性别，类型什么的），不适合建索引，更新非常频繁的数据不适宜建索引

### 哪些常见情况不能用索引?

like "%xxx" not in ， !=

对列进行函数运算的情况


## 5. JSON能不能跨域

浏览器有一个很重要安全性限制，即为同源策略：不同域的客户端脚本在无明确授权的情况下不能读些对方资源。跨域也就是不同源

只要协议，端口，域名有一个不同，即为跨域！

1. **使用JSONP实现跨域（仅适用于GET请求）：**
实现原理：*script* 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件，而并不要求同源。
所以 JSONP 的理念就是，我和服务端约定好一个函数名，当我请求文件的时候，服务端返回一段 JavaScript。这段 JavaScript 调用了我们约定好的函数，并且将数据当做参数传入。

2. **使用HTML5的window.postMessage方法来跨域传送数据**

## 6. session与cookie的区别：

参考博文(https://cr1753343566.github.io/2018/09/AJAX%E4%B8%8ESessionAndCookie/)

## 7. 反射

反射主要功能：得到一个对象所属的类，获取一个类的所有的成员变量和方法，在运行时创建对象，在运行时调用对象的方法

反射的实现方法：
1. 通过Object类的getClass方法
    
        Foo foo = new Foo();
        Class cla = foo.getClass();
2. 类名.class
3. class.forName("类路径")

反射能不能调用类的私有方法：

可以，反射可以调用类的私有方法，但不能调用父类的私有方法

## 8. 数据库引擎：

1. MyISAM 不支持事务，表存储为三个文件，后缀名为.myd——存储数据.myi——存储索引 .frm——存储表结构
    >MyISAM支持三种不同的存储格式：
    >
    >1.静态型：默认的存储结构，字段都是不可变的字段。存储时，列的宽度不足会自动使用空格补足，访问时不会得到空格这种存储的优点是：存储迅速，容易缓存，出现故障易修复
    >
    >2.动态型：字段可变，但频繁的更新删除记录会产生碎片，需要定期改善性能，出现故障的时候恢复比较困难
    >
    >3.压缩表：占用磁盘空间，每个记录单独压缩，只有非常小的访问开支

2. MEMORY存储引擎，将表中所有数据存放在内存中，如果数据库崩溃或重启，数据都会消失，适合存储临时数据的临时表，以及数据仓库中的表，默认情况下，MEMORY引擎使用的时Hash索引，MEMORY只支持表锁，并发性能差

3. InnoDB 支持事务，提供数据的回滚和崩溃修复能力、多版本并控制的事务安全型表。InnoDB提供行级锁。缺点：读写性能差，占用空间比较大，提供外键约束


## 9. http请求流程

1. 用户通过浏览器输入连接地址请求所需的资源
2. 浏览器接收用户的请求，并把请求组装成指定的格式发送给服务器端，客户端与服务器端通过HTTP进行具体的交互。其中请求的数据流中主要包含HTTP请求方法，请求的网址，以及请求的一些参数信息
3. 服务器接收到客户端发来的请求，并查找用户需要的资源
4. 服务器查找到请求的资源，并把资源返回给客户端
5. 服务器端通过响应信息组装成特定的消息格式后返回给客户端，这个过程通过HTTP来完成。响应的数据流主要包含状态编码，Context-Type，响应消息的内容（图片或HTML形式的内容）
6. 浏览器对HTML进行解析，并把结果展现给用户

## 10. GET和POST方法的区别

1. GET主要从服务器端获取用户所需的资源，并将其作为响应返回给客户端，GET方法不会影响到资源自身的状态
2. POST方法提供向服务器上传数据的功能
3. GET方法明文提交书记。POST方法密文提交
4. 使用GET方法传送数据的时候，一般将数据添加到URL后面，用?连接，各个变量用&& 连接，由于对URL的长度的限制，这种方法提交的数据量非常小
5. POST方法提交数据的时候是通过HTTP附件的形式进行的，传送的数据量更大一些，一般不受限制








